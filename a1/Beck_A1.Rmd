# Ch 1

### 1.
```{r}
help.start()
?var
```

### 2.
**correct**: 
almost any alphanumeric combination: e.g., a1

**incorrect**:
g!% <- c(1:5)


### 3.
```{r}
x <- 9
objects()
rm(x)
```

# Ch 2

### 1.
```{r}
x <- (1:26)
v <- x[1:5] == 2 + 3
w <- sample(x, 5)
y <- x[-(1:15)]
alpha <- names(x) <- letters
```

### 3.
```{r}
df <- data.frame(x, alpha)
df[,3] <- sample(c(1:3), 26, replace = T)
df[1,1] <- NA
sum(df[,1])
```

# CH 3
```{r}
mode (y)
y <- as.character(y)
attributes(alpha)
attr(alpha, "dim") <- c(1, 26)
```

# Ch 4

### 1.
```{r}
state <- c("tas", "sa", "qld", "nsw", "nsw", "nt", "wa", "wa",
           "qld", "vic", "nsw", "vic", "qld", "qld", "sa", "tas",
           "sa", "nt", "wa", "vic", "qld", "nsw", "nsw", "wa",
           "sa", "act", "nsw", "vic", "vic", "act")
statef <- factor(state)
incomes <- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,
             61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,
             59, 46, 58, 43)
incmeans <- tapply(incomes, statef, mean)
?t.test
t.test(incmeans, alternative = "two.sided", conf.level = 0.95)
```

### 2.
Ordered by the levels of the factor - gives different contrasts.

# Ch 5

### 1.
```{r}
Ar <- rep(1, 36)
dim(Ar) <- c(3, 6, 2)
Ar[1, 1, 1] <- 0
Ar[, , 2] <- 5
Ar[1, , 2] <- 2
```

### 2.
```{r}
y <- sample(1:20, 100, replace = T)
xyz <- array(y, dim = c(10, 10))
temp <- array(c(1:10, 1:10), dim = c(10, 2))
xyz[temp] <- 0
xyz
```

### 3.
```{r}
x <- c(10,10)
zyx <- array(y, x)
zyx == xyz
```

### 4.
```{r}
x <- sample(1:10, 36, replace = T)
dim(x) <- c(3, 6, 2)
Ar+x
Ar-x
Ar*x
Ar/x
Ar%o%x
```

###5.
```{r}
dim(zyx) <- NULL
```

# Ch 6

### 1.

```{r}
list <- list(who = "Mark", verb = "needs",
             what = "a whiskey" )
list[[3]]
list$who
list["verb"]
```

### 2.
```{r}
listb <- list(who = "Mark", verb = "has", what  = "a bad sunburn")
 list(list, listb)
c(list, listb)
```
It uses a single data structure - i.e., they're no longer stored as separate lists?

### 3.
Data frames are "special cases" of lists - lists with additional restrictions.

### 4.
The attach function allows you to directly search data frames or lists for variables - more convenient than using $.

# Ch 7

### 1.

1. read.table()
2. load()
3. read.csv()
4. scan()
5. more

Plus many other reads for other files - foriegn needed for reading other stat program files

# Ch 8

### 1.
```{r}
dat <- rnorm(150, mean = 10, sd = 1)
summary(dat)
hist(dat, prob=T)
```

### 2.
```{r}
dat <- rt(200, 5, 1)
summary(dat)
hist(dat)

qqnorm(dat)
qqline(dat)

shapiro.test(dat)
```

# Ch 9

### 1.
If () else returns a single value while ifelse() returns an entire vector

### 2.
```{r}
n <- 2
x <- matrix(0, nrow = 10, ncol = 2)
for (i in 1:n) {
  y <- sample(1:20, 10, replace = T)
  x[,i] <- y
}
```